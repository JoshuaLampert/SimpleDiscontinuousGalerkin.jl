var documenterSearchIndex = {"docs":
[{"location":"ref-trixibase/#TrixiBase.jl-API","page":"TrixiBase","title":"TrixiBase.jl API","text":"","category":"section"},{"location":"ref-trixibase/#TrixiBase.disable_debug_timings-Tuple{}","page":"TrixiBase","title":"TrixiBase.disable_debug_timings","text":"disable_debug_timings()\n\nDisable all @trixi_timeit timings. The timings should be optimized away, allowing for truly zero-overhead. Enable timings again with enable_debug_timings.\n\nSee also enable_debug_timings, @trixi_timeit.\n\n\n\n\n\n","category":"method"},{"location":"ref-trixibase/#TrixiBase.enable_debug_timings-Tuple{}","page":"TrixiBase","title":"TrixiBase.enable_debug_timings","text":"enable_debug_timings()\n\nEnable all @trixi_timeit timings (default behavior).\n\nSee also disable_debug_timings, @trixi_timeit.\n\n\n\n\n\n","category":"method"},{"location":"ref-trixibase/#TrixiBase.timer-Tuple{}","page":"TrixiBase","title":"TrixiBase.timer","text":"timer()\n\nMain timer for global timing, e.g., to be used with @trixi_timeit.\n\n\n\n\n\n","category":"method"},{"location":"ref-trixibase/#TrixiBase.trixi_include-Tuple{Function, Module, AbstractString}","page":"TrixiBase","title":"TrixiBase.trixi_include","text":"trixi_include([mapexpr::Function=identity,] [mod::Module=Main,] elixir::AbstractString; kwargs...)\n\ninclude the file elixir and evaluate its content in the global scope of module mod. You can override specific assignments in elixir by supplying keyword arguments. Its basic purpose is to make it easier to modify some parameters while running simulations from the REPL. Additionally, this is used in tests to reduce the computational burden for CI while still providing examples with sensible default values for users.\n\nBefore replacing assignments in elixir, the keyword argument maxiters is inserted into calls to solve with it's default value used in the SciML ecosystem for ODEs, see the \"Miscellaneous\" section of the documentation.\n\nThe optional first argument mapexpr can be used to transform the included code before it is evaluated: for each parsed expression expr in elixir, the include function actually evaluates mapexpr(expr). If it is omitted, mapexpr defaults to identity.\n\nExamples\n\njulia> using TrixiBase, Trixi\n\njulia> redirect_stdout(devnull) do\n         trixi_include(@__MODULE__, joinpath(examples_dir(), \"tree_1d_dgsem\", \"elixir_advection_extended.jl\"),\n                       tspan=(0.0, 0.1))\n         sol.t[end]\n       end\n[ Info: You just called `trixi_include`. Julia may now compile the code, please be patient.\n0.1\n\n\n\n\n\n","category":"method"},{"location":"ref-trixibase/#TrixiBase.trixi_include_changeprecision-Tuple{Any, Module, AbstractString}","page":"TrixiBase","title":"TrixiBase.trixi_include_changeprecision","text":"trixi_include_changeprecision(T, [mod::Module=Main,] elixir::AbstractString; kwargs...)\n\ninclude the elixir elixir and evaluate its content in the global scope of module mod. You can override specific assignments in elixir by supplying keyword arguments, similar to trixi_include.\n\nThe only difference to trixi_include is that the precision of floating-point numbers in the included elixir is changed to T. More precisely, the package ChangePrecision.jl is used to convert all Float64 literals, operations like / that produce Float64 results, and functions like ones that return Float64 arrays by default, to the desired type T. See the documentation of ChangePrecision.jl for more details.\n\nThe purpose of this function is to conveniently run a full simulation with Float32, which is orders of magnitude faster on most GPUs than Float64, by just including the elixir with trixi_include_changeprecision(Float32, elixir). Many constructors in the Trixi.jl framework are written in a way that changing all floating-point arguments to Float32 will change the element type to Float32 as well. In TrixiParticles.jl, including an elixir with this macro should be sufficient to run the full simulation with single precision.\n\n\n\n\n\n","category":"method"},{"location":"ref-trixibase/#TrixiBase.@trixi_timeit-Tuple{Any, Any, Any}","page":"TrixiBase","title":"TrixiBase.@trixi_timeit","text":"@trixi_timeit timer() \"some label\" expression\n\nBasically the same as a special case of @timeit_debug from TimerOutputs.jl, but without try ... finally ... end block. Thus, it's not exception-safe, but it also avoids some related performance problems. Since we do not use exception handling in Trixi.jl, that's not really an issue.\n\nAll @trixi_timeit timings can be disabled with disable_debug_timings. The timings should then be optimized away, allowing for truly zero-overhead.\n\nSee also disable_debug_timings, enable_debug_timings.\n\n\n\n\n\n","category":"macro"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"MIT License","category":"page"},{"location":"license/","page":"License","title":"License","text":"Copyright (c) 2025-present Joshua Lampert <joshua.lampert@uni-hamburg.de> and contributors","category":"page"},{"location":"license/","page":"License","title":"License","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","category":"page"},{"location":"license/","page":"License","title":"License","text":"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","category":"page"},{"location":"license/","page":"License","title":"License","text":"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"development/#Development","page":"Development","title":"Development","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"If you have any suggestions or ideas for improvements or new features, we are pleased to accept and discuss issues or if you are willing to contribute, feel free to open a pull request, even if it is only fixing a typo or improving the docs.","category":"page"},{"location":"development/#Changing-SimpleDiscontinuousGalerkin.jl-and-running-it-locally","page":"Development","title":"Changing SimpleDiscontinuousGalerkin.jl and running it locally","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"If you plan to edit SimpleDiscontinuousGalerkin.jl, you first need to clone a local copy of the repository, which can be done by using git. It is recommended that you create a project, e.g. call it run, inside the repository, where you can add packages that you use during executing and testing SimpleDiscontinuousGalerkin.jl, but are not needed by SimpleDiscontinuousGalerkin.jl. This way you can keep the Project.toml of the main repository clean. To do so, you can execute the following lines in a terminal:","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"git clone https://github.com/JoshuaLampert/SimpleDiscontinuousGalerkin.jl.git\ncd SimpleDiscontinuousGalerkin\nmkdir run\ncd run\njulia --project=. -e 'using Pkg; Pkg.develop(PackageSpec(path=\"..\"))' # Install local SimpleDiscontinuousGalerkin.jl clone\njulia --project=. -e 'using Pkg; Pkg.add([\"OrdinaryDiffEqLowStorageRK\", \"Plots\"])' # Install additional packages","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"If you use other packages for executing SimpleDiscontinuousGalerkin.jl, you can add them to the project in the run directory in an analogous way as above. To use the Julia project within run, be sure to start the Julia REPL by","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia --project=.","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"if already inside the the run directory or julia --project=run if in the main directory of the repo.","category":"page"},{"location":"development/#Preview-of-the-documentation","page":"Development","title":"Preview of the documentation","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"If you want to build the documentation locally, you can run","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia --project=docs -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"once from the SimpleDiscontinuousGalerkin.jl main directory to tell Documenter.jl to build the documentation of your local clone. To build the documentation, run","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia --project=docs --color=yes docs/make.jl","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"The resulting .html files can then be found in docs/build/ and you can look at them by opening them in a browser. For pull requests from the main repository (i.e. not from a fork), the documentation is automatically built and can be previewed under https://JoshuaLampert.github.io/SimpleDiscontinuousGalerkin.jl/previews/PRXXX/ where XXX is the number of the pull request.","category":"page"},{"location":"development/#Testing","page":"Development","title":"Testing","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"In the test suite of SimpleDiscontinuousGalerkin.jl, the results of the examples are tested against reference solutions. This means that if you add an example and verified it works as expected, you should put the reference solution into the corresponding test. To obtain the reference solution and automatically copy it into the clipboard, you can run","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"errs = errors(analysis_callback)\nints = integrals(analysis_callback)\nusing InteractiveUtils\nclipboard(\"l2=$(errs.l2_error[:, end])\\n, linf=$(errs.linf_error[:, end])\\n, cons_error=$(errs.conservation_error[:, end])\\n, change_mass=$(ints.mass[end] - ints.mass[1]),\\nchange_entropy=$(ints.entropy[end] - ints.entropy[1]), \\nentropy_timederivative=$(ints.entropy_timederivative[end])\")","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"Note that some of the quantities are only computed if they are included in the analysis_callback, which means that you might need to adjust the above command depending on which quantities you want to test for.","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"This package provides a simple implementation of Discontinuous Galerkin (DG) methods for solving hyperbolic conservation laws. It is designed to be easy to understand and extend, making it suitable for educational purposes and quick prototyping of new ideas. It is not intended for high-performance computing or production use. Many ideas and concepts are inspired by the package Trixi.jl and most users will likely want to use that package instead. For the basic concepts of Discontinuous Galerkin methods, which are mostly the same as in Trixi.jl, please refer to the Trixi.jl documentation. The syntax of the API is very similar to Trixi.jl. Please check out the examples/ folder for some usage examples.","category":"page"},{"location":"overview/#Differences-to-Trixi.jl","page":"Overview","title":"Differences to Trixi.jl","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The focus of SimpleDiscontinuousGalerkin.jl is on understandability and extendability of the code and less on performance and a wide variety of features. It is designed to closely follow the mathematical description of the DG method, which can make it suitable for teaching and learning purposes. For example, SimpleDiscontinuousGalerkin.jl implements more equivalent formulations like weak and strong formulation of the flux-differencing method to demonstrate the equivalence of these formulations.\nSimpleDiscontinuousGalerkin.jl has no support for many features Trixi.jl has (many more equations, multiple space dimensions, more sophisticated numerical fluxes, adaptive mesh refinement, shock capturing, positivity-preserving methods, limiting strategies, callbacks, parallel computing, etc.).\nSimpleDiscontinuousGalerkin.jl has some (rather niche) features Trixi.jl does not support (yet), which stem from quick tests and prototyping to test some new ideas. This includes different numerical fluxes at the boundary than in the interior and different bases for each element via the PerElementFDSBP solver.\nSimpleDiscontinuousGalerkin.jl supports bases, which do not include the boundary nodes (e.g. Gauss-Legendre basis), while Trixi.jl only supports bases including the boundary nodes (e.g. Gauss-Lobatto basis) utilizing the PolynomialBasesDerivativeOperator from SummationByPartsOperatorsExtra.jl.\nSimpleDiscontinuousGalerkin.jl has support for one-dimensional overset grid (Chimera) methods.\nSimpleDiscontinuousGalerkin.jl supports an interface for solving Riemann problems and has a full Godunov flux for the compressible Euler equations.\nIn contrast to Trixi.jl, which implements an own Gauss-Lobatto-Legendre basis for the Discontinuous Galerkin spectral element method (DGSEM), this package highlights more the underlying summation-by-parts (SBP) structure of the DG method. It reuses the legendre_derivative_operator from SummationByPartsOperators.jl for the Discontinuous Galerkin spectral element method (DGSEM). This can be seen as a special case of FDSBP with the underlying SBP operator being the (Gauss-Lobatto-)Legendre derivative operator.","category":"page"},{"location":"ref/#SimpleDiscontinuousGalerkin.jl-API","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.jl API","text":"","category":"section"},{"location":"ref/#SimpleDiscontinuousGalerkin.SimpleDiscontinuousGalerkin","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.SimpleDiscontinuousGalerkin","text":"SimpleDiscontinuousGalerkin\n\nSimpleDiscontinuousGalerkin.jl is a Julia package that implements some basic discontinuous Galerkin (DG) methods for the solution of hyperbolic partial differential equations (PDEs). The package is designed to be simple and easy to use and understand. It is intended for educational purposes and to provide a starting point for more complex DG methods. For a more comprehensive and advanced implementation of DG methods, we recommend using the package Trixi.jl. This package can be understood as a minimalistic version of Trixi.jl, which is designed to be easy to understand and modify. Many design concepts are inspired by Trixi.jl, but the implementation is much simpler and more straightforward.\n\nSimpleDiscontinuousGalerkin.jl builds on the foundations of the package SummationByPartsOperators.jl.\n\nSee also: SimpleDiscontinuousGalerkin.jl\n\n\n\n\n\n","category":"module"},{"location":"ref/#Equations","page":"SimpleDiscontinuousGalerkin","title":"Equations","text":"","category":"section"},{"location":"ref/#SimpleDiscontinuousGalerkin.BurgersEquation1D","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.BurgersEquation1D","text":"BurgersEquation1D\n\nThe inviscid Burgers' equation\n\npartial_t u + frac12 partial_1 u^2 = 0\n\nin one space dimension.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.flux_ec-Tuple{Any, Any, BurgersEquation1D}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.flux_ec","text":"flux_ec(u_ll, u_rr, equations::BurgersEquation1D)\n\nEntropy-conserving, symmetric flux for the inviscid Burgers' equation.\n\nF(u_L u_R) = fracu_L^2 + u_L u_R + u_R^26\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.initial_condition_convergence_test-Tuple{Any, Any, BurgersEquation1D}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::BurgersEquation1D)\n\nA smooth initial condition used for convergence tests.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.source_terms_convergence_test-Tuple{Any, Any, Any, BurgersEquation1D}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.source_terms_convergence_test","text":"source_terms_convergence_test(u, x, t, equations::BurgersEquation1D)\n\nSource terms used for convergence tests in combination with initial_condition_convergence_test.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.CompressibleEulerEquations1D","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.CompressibleEulerEquations1D","text":"CompressibleEulerEquations1D(gamma)\n\nThe compressible Euler equations\n\nfracpartialpartial t\nbeginpmatrix\nrho  rho v_1  rho e\nendpmatrix\n+\nfracpartialpartial x\nbeginpmatrix\nrho v_1  rho v_1^2 + p  (rho e +p) v_1\nendpmatrix\n=\nbeginpmatrix\n0  0  0\nendpmatrix\n\nfor an ideal gas with ratio of specific heats gamma in one space dimension. Here, rho is the density, v_1 the velocity, e the specific total energy rather than specific internal energy, and\n\np = (gamma - 1) left( rho e - frac12 rho v_1^2 right)\n\nthe pressure.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.flux_kennedy_gruber-Tuple{Any, Any, CompressibleEulerEquations1D}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.flux_kennedy_gruber","text":"flux_kennedy_gruber(u_ll, u_rr, equations::CompressibleEulerEquations1D)\n\nKinetic energy preserving two-point flux by\n\nKennedy and Gruber (2008) Reduced aliasing formulations of the convective terms within the Navier-Stokes equations for a compressible fluid DOI: 10.1016/j.jcp.2007.09.020\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.flux_ranocha-Tuple{Any, Any, CompressibleEulerEquations1D}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.flux_ranocha","text":"flux_ranocha(u_ll, u_rr, equations::CompressibleEulerEquations1D)\n\nEntropy conserving and kinetic energy preserving two-point flux by\n\nHendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws PhD thesis, TU Braunschweig\n\nSee also\n\nHendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators Proceedings of ICOSAHOM 2018\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerEquations1D}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::CompressibleEulerEquations1D)\n\nA smooth initial condition used for convergence tests in combination with source_terms_convergence_test (and BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.initial_condition_density_wave-Tuple{Any, Any, CompressibleEulerEquations1D}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.initial_condition_density_wave","text":"initial_condition_density_wave(x, t, equations::CompressibleEulerEquations1D)\n\nA sine wave in the density with constant velocity and pressure; reduces the compressible Euler equations to the linear advection equations. This setup is the test case for stability of EC fluxes from the paper\n\nGregor J. Gassner, Magnus Svärd, Florian J. Hindenlang (2020) Stability issues of entropy-stable and/or split-form high-order schemes arXiv: 2007.09026\n\nwith the following parameters\n\ndomain [-1, 1]\nmesh = 4x4\npolydeg = 5\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerEquations1D}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.initial_condition_weak_blast_wave","text":"initial_condition_weak_blast_wave(x, t, equations::CompressibleEulerEquations1D)\n\nA weak blast wave taken from\n\nSebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG arXiv: 2008.12044\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerEquations1D}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.source_terms_convergence_test","text":"source_terms_convergence_test(u, x, t, equations::CompressibleEulerEquations1D)\n\nSource terms used for convergence tests in combination with initial_condition_convergence_test (and BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.AbstractEquations","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.AbstractEquations","text":"AbstractEquations{NDIMS, NVARS}\n\nAn abstract supertype of specific equations such as the linear advection equation. The type parameters encode the number of spatial dimensions (NDIMS) and the number of primary variables (NVARS) of the physics model.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.cons2cons-Tuple{Any, SimpleDiscontinuousGalerkin.AbstractEquations}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.cons2cons","text":"cons2cons(u, equations)\n\nReturn the conservative variables u. While this function is as trivial as identity, it is also as useful.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.cons2entropy-Tuple{Any, SimpleDiscontinuousGalerkin.AbstractEquations{1, 1}}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.cons2entropy","text":"cons2entropy(u, equations)\n\nReturn the entropy variables from the conservative variables u for the given system of equations. The entropy variables are defined as the derivative of the entropy with respect to the conservative variables.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.cons2prim-Tuple{Any, SimpleDiscontinuousGalerkin.AbstractEquations{1, 1}}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.cons2prim","text":"cons2prim(u, equations)\n\nReturn the primitive variables from the conservative variables u.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.default_analysis_errors-Tuple{SimpleDiscontinuousGalerkin.AbstractEquations}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.default_analysis_errors","text":"default_analysis_errors(equations)\n\nDefault analysis errors used by the AnalysisCallback.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.default_analysis_integrals-Tuple{SimpleDiscontinuousGalerkin.AbstractEquations}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.default_analysis_integrals","text":"default_analysis_integrals(equations)\n\nDefault analysis integrals used by the AnalysisCallback.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.eachvariable-Tuple{SimpleDiscontinuousGalerkin.AbstractEquations}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.eachvariable","text":"eachvariable(equations::AbstractEquations)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the variables in equations. In particular, not the variables themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.entropy-Tuple{Any, SimpleDiscontinuousGalerkin.AbstractEquations{1, 1}}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.entropy","text":"entropy(u, equations)\n\nReturn the entropy of the conservative variables u for the given system of equations.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.entropy_timederivative","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.entropy_timederivative","text":"entropy_timederivative\n\nThe semi-discrete time derivative of the entropy, which can be used in the AnalysisCallback to compute the time derivative of the entropy.\n\n\n\n\n\n","category":"function"},{"location":"ref/#SimpleDiscontinuousGalerkin.get_name-Tuple{SimpleDiscontinuousGalerkin.AbstractEquations}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.get_name","text":"get_name(equations::AbstractEquations)\n\nReturn the canonical, human-readable name for the given system of equations.\n\nExamples\n\njulia> SimpleDiscontinuousGalerkin.get_name(LinearAdvectionEquation1D(1.0))\n\"LinearAdvectionEquation1D\"\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.mass-Tuple{Any, SimpleDiscontinuousGalerkin.AbstractEquations{1, 1}}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.mass","text":"mass(u, equations)\n\nReturn the mass of the conservative variables u for the given system of equations.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.prim2cons-Tuple{Any, SimpleDiscontinuousGalerkin.AbstractEquations{1, 1}}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.prim2cons","text":"prim2cons(q, equations)\n\nReturn the conservative variables from the primitive variables q.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.LinearAdvectionEquation1D","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.LinearAdvectionEquation1D","text":"LinearAdvectionEquation1D\n\nThe linear scalar advection equation\n\npartial_t u + a partial_1 u  = 0\n\nin one space dimension with constant velocity a.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.initial_condition_convergence_test-Tuple{Any, Any, LinearAdvectionEquation1D}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::LinearAdvectionEquation1D)\n\nA smooth initial condition used for convergence tests.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.MaxwellEquations1D","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.MaxwellEquations1D","text":"MaxwellEquations1D(c = 299_792_458.0)\n\nThe Maxwell equations of electro dynamics\n\nfracpartialpartial t\nbeginpmatrix\nE  B\nendpmatrix\n+\nfracpartialpartial x\nbeginpmatrix\nc^2 B  E\nendpmatrix\n=\nbeginpmatrix\n0  0\nendpmatrix\n\nin one dimension with speed of light c = 299792458 m/s (in vacuum). In one dimension the Maxwell equations reduce to a wave equation. The orthogonal magnetic (e.g.B_y) and electric field (E_z) propagate as waves through the domain in x-direction. For reference, see\n\ne.g. p.15 of Numerical Methods for Conservation Laws: From Analysis to Algorithms https://doi.org/10.1137/1.9781611975109\nor equation (1) in https://inria.hal.science/hal-01720293/document\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.initial_condition_convergence_test-Tuple{Any, Any, MaxwellEquations1D}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::MaxwellEquations1D)\n\nA smooth initial condition used for convergence tests.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.flux_hll","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.flux_hll","text":"flux_hll\n\nSee FluxHLL.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#SimpleDiscontinuousGalerkin.flux_lax_friedrichs","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.flux_lax_friedrichs","text":"flux_lax_friedrichs\n\nSee FluxLaxFriedrichs.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#SimpleDiscontinuousGalerkin.DissipationLocalLaxFriedrichs","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.DissipationLocalLaxFriedrichs","text":"DissipationLocalLaxFriedrichs(max_abs_speed=max_abs_speed)\n\nCreate a local Lax-Friedrichs dissipation operator where the maximum absolute wave speed is estimated as max_abs_speed(u_ll, u_rr, equations), defaulting to max_abs_speed.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.FluxHLL","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.FluxHLL","text":"FluxHLL(min_max_speed=min_max_speed_davis)\n\nCreate an HLL (Harten, Lax, van Leer) numerical flux where the minimum and maximum wave speeds are estimated as λ_min, λ_max = min_max_speed(u_ll, u_rr, orientation_or_normal_direction, equations), defaulting to min_max_speed_davis. Original paper:\n\nAmiram Harten, Peter D. Lax, Bram van Leer (1983) On Upstream Differencing and Godunov-Type Schemes for Hyperbolic Conservation Laws DOI: 10.1137/1025002\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.FluxLaxFriedrichs","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.FluxLaxFriedrichs","text":"FluxLaxFriedrichs(max_abs_speed=max_abs_speed)\n\nLocal Lax-Friedrichs (Rusanov) flux with maximum wave speed estimate provided by max_abs_speed, cf. DissipationLocalLaxFriedrichs and max_abs_speed.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.FluxPlusDissipation","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.FluxPlusDissipation","text":"FluxPlusDissipation(numerical_flux, dissipation)\n\nCombine a numerical_flux with a dissipation operator to create a new numerical flux.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.RiemannProblem","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.RiemannProblem","text":"RiemannProblem(u_ll, u_rr)\n\nCreate a Riemann problem with left and right states u_ll and u_rr, which can be solved with a RiemannSolver. This is used for the flux_godunov numerical flux.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.RiemannSolver","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.RiemannSolver","text":"RiemannSolver(prob, equations)\n\nAn exact Riemann solver of the RiemannProblem prob for equations.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.RiemannSolverSolution","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.RiemannSolverSolution","text":"RiemannSolverSolution\n\nA solution of a Riemann problem, which is a vector of states at different times. Is returned when solveing a RiemannProblem with a RiemannSolver.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.flux_central-Tuple{Any, Any, SimpleDiscontinuousGalerkin.AbstractEquations}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.flux_central","text":"flux_central(u_ll, u_rr, equations::AbstractEquations)\n\nThe classical central numerical flux f((u_ll) + f(u_rr)) / 2. When this flux is used as volume flux, the discretization is equivalent to the classical weak form DG method (except floating point errors).\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.flux_godunov-Tuple{Any, Any, Any}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.flux_godunov","text":"flux_godunov(u_ll, u_rr, equations)\n\nNumerical flux using the RiemannSolver to solve Riemann problems with left and right states u_ll and u_rr for the given equations exactly.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.max_abs_speed","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.max_abs_speed","text":"max_abs_speed(u_ll, u_rr, equations)\n\nSimple and fast estimate of the maximal wave speed of the Riemann problem with left and right states u_ll, u_rr, based only on the local wave speeds associated to u_ll and u_rr.\n\n\n\n\n\n","category":"function"},{"location":"ref/#SimpleDiscontinuousGalerkin.min_max_speed_davis","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.min_max_speed_davis","text":"min_max_speed_davis(u_ll, u_rr, equations)\n\nSimple and fast estimates of the minimal and maximal wave speed of the Riemann problem with left and right states u_ll, u_rr, usually based only on the local wave speeds associated to u_ll and u_rr.\n\nS.F. Davis (1988) Simplified Second-Order Godunov-Type Methods DOI: 10.1137/0909030\n\nSee eq. (10.38) from\n\nEleuterio F. Toro (2009) Riemann Solvers and Numerical Methods for Fluid Dynamics: A Practical Introduction DOI: 10.1007/b79761\n\nSee also FluxHLL, min_max_speed_davis.\n\n\n\n\n\n","category":"function"},{"location":"ref/#Mesh","page":"SimpleDiscontinuousGalerkin","title":"Mesh","text":"","category":"section"},{"location":"ref/#SimpleDiscontinuousGalerkin.InhomogeneousMesh","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.InhomogeneousMesh","text":"InhomogeneousMesh{NDIMS, RealT}\nInhomogeneousMesh(coordinates)\n\nCreate an inhomogeneous one-dimensional mesh from the given coordinates.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.Mesh","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.Mesh","text":"Mesh\n\nStruct that holds the information for a simple homogeneous one-dimensional mesh.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.Mesh-Tuple{Any, Any, Any}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.Mesh","text":"Mesh(xmin, xmax, N_elements)\n\nCreate a simple homogeneous one-dimensional mesh from xmin to xmax with N_elements elements.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.OversetGridMesh","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.OversetGridMesh","text":"OversetGridMesh{NDIMS, RealT, MeshLeft, MeshRight}\nOversetGridMesh(mesh_left, mesh_right)\n\nCreate an overset grid (Chimera) mesh that combines two meshes, mesh_left and mesh_right, which have an overlap region.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.element_spacing-Tuple{Mesh}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.element_spacing","text":"element_spacing(mesh::AbstractMesh)\n\nReturn the spacing of the elements in the mesh. This is the length of each element, which is the same for all elements in a homogeneous Mesh and can be different for each element in an InhomogeneousMesh.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.element_spacing-Tuple{SimpleDiscontinuousGalerkin.AbstractMesh, Any}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.element_spacing","text":"element_spacing(mesh::AbstractMesh, element)\n\nReturn the length of the element element in the mesh.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.left_element_boundary-Tuple{SimpleDiscontinuousGalerkin.AbstractMesh, Any}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.left_element_boundary","text":"left_element_boundary(mesh::AbstractMesh, element)\n\nReturn the left boundary coordinate of the element element in the mesh.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.xmax-Tuple{Mesh}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.xmax","text":"xmax(mesh::AbstractMesh)\n\nReturn the maximum coordinate of the mesh.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.xmin-Tuple{Mesh}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.xmin","text":"xmin(mesh::AbstractMesh)\n\nReturn the minimum coordinate of the mesh.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Boundary-conditions","page":"SimpleDiscontinuousGalerkin","title":"Boundary conditions","text":"","category":"section"},{"location":"ref/#SimpleDiscontinuousGalerkin.boundary_condition_do_nothing","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.boundary_condition_do_nothing","text":"boundary_condition_do_nothing = BoundaryConditionDoNothing()\n\nImposing no boundary condition just evaluates the flux at the inner state.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#SimpleDiscontinuousGalerkin.boundary_condition_periodic","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.boundary_condition_periodic","text":"boundary_condition_periodic = BoundaryConditionPeriodic()\n\nA singleton struct indicating periodic boundary conditions.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#SimpleDiscontinuousGalerkin.BoundaryConditionDirichlet","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.BoundaryConditionDirichlet","text":"BoundaryConditionDirichlet(boundary_value_function)\n\nCreate a Dirichlet boundary condition that uses the function boundary_value_function to specify the values at the boundary. This can be used to create a boundary condition that specifies exact boundary values by passing the exact solution of the equation. The passed boundary value function will be called with the same arguments as an initial condition function is called, i.e., as\n\nboundary_value_function(x, t, equations)\n\nwhere x specifies the coordinates, t is the current time, and equation is the corresponding system of equations.\n\nExamples\n\njulia> BoundaryConditionDirichlet(initial_condition_convergence_test)\n\n\n\n\n\n","category":"type"},{"location":"ref/#Solver","page":"SimpleDiscontinuousGalerkin","title":"Solver","text":"","category":"section"},{"location":"ref/#SimpleDiscontinuousGalerkin.DG","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.DG","text":"DG(; basis, surface_integral, volume_integral)\n\nCreate a discontinuous Galerkin method. If basis isa LegendreDerivativeOperator, this creates a DGSEM.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.eachnode-Tuple{SimpleDiscontinuousGalerkin.DG, Any}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.eachnode","text":"eachnode(solver::DG, element)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the nodes in a specific element in solver. In particular, not the nodes themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.get_variable-Tuple{Any, Any, SimpleDiscontinuousGalerkin.DG}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.get_variable","text":"get_variable(u, v, ::DG)\n\nReturn the solution belonging to the variable v of the solution u at one time step as a vector at every node across all elements.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.DGSEM","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.DGSEM","text":"DGSEM(; RealT=Float64, polydeg::Integer,\n        surface_flux=flux_central,\n        surface_integral=SurfaceIntegralWeakForm(surface_flux),\n        volume_integral=VolumeIntegralWeakForm())\n\nCreate a discontinuous Galerkin spectral element method (DGSEM) using a LegendreDerivativeOperator with polynomials of degree polydeg.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.FDSBP","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.FDSBP","text":"FDSBP(D; RealT=Float64,\n         surface_flux=flux_central,\n         surface_integral=SurfaceIntegralWeakForm(surface_flux),\n         volume_integral=VolumeIntegralWeakForm())\n\nCreate a discontinuous Galerkin method using a summation-by-parts operator D from SummationByPartsOperators.jl. This is similar to the DGSEM, but uses a general derivative operator instead of a Legendre derivative operator.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.PerElementBasis","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.PerElementBasis","text":"PerElementBasis{BasisType}\n\nBasis, which can hold a different SBP operator for each element. This is used in PerElementFDSBP to allow for different bases on each element.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.PerElementFDSBP","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.PerElementFDSBP","text":"PerElementFDSBP(bases::Vector{BasisType};\n                surface_flux = flux_central,\n                surface_integral = SurfaceIntegralWeakForm(surface_flux),\n                volume_integral = VolumeIntegralWeakForm()) where BasisType\n\nCreate a discontinuous Galerkin method using different bases for each element. This is like FDSBP, but allows for a different SBP operator on each element. See also: PerElementBasis.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.SurfaceIntegralStrongForm","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.SurfaceIntegralStrongForm","text":"SurfaceIntegralStrongForm(surface_flux=flux_central, surface_flux_boundary=surface_flux)\n\nThe classical strong form surface integral type for FD/DG methods. It uses surface_flux for the interior fluxes and surface_flux_boundary for the boundary fluxes.\n\nSee also VolumeIntegralStrongForm.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.SurfaceIntegralWeakForm","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.SurfaceIntegralWeakForm","text":"SurfaceIntegralWeakForm(surface_flux=flux_central, surface_flux_boundary=surface_flux)\n\nThe classical weak form surface integral type for DG methods as explained in standard textbooks. It uses surface_flux for the interior fluxes and surface_flux_boundary for the boundary fluxes.\n\nSee also VolumeIntegralWeakForm.\n\nReferences\n\nKopriva (2009) Implementing Spectral Methods for Partial Differential Equations: Algorithms for Scientists and Engineers doi: 10.1007/978-90-481-2261-5\nHesthaven, Warburton (2007) Nodal Discontinuous Galerkin Methods: Algorithms, Analysis, and Applications doi: 10.1007/978-0-387-72067-8\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.VolumeIntegralFluxDifferencing","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.VolumeIntegralFluxDifferencing","text":"VolumeIntegralFluxDifferencing(volume_flux=flux_central)\n\nVolume integral type for DG methods based on SBP operators and flux differencing using a symmetric two-point volume_flux. This volume_flux needs to satisfy the interface of numerical fluxes.\n\nTo be used together with SurfaceIntegralWeakForm.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.VolumeIntegralFluxDifferencingStrongForm","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.VolumeIntegralFluxDifferencingStrongForm","text":"VolumeIntegralFluxDifferencingStrongForm(volume_flux=flux_central)\n\nVolume integral type for DG methods based on SBP operators and flux differencing using a symmetric two-point volume_flux. This volume_flux needs to satisfy the interface of numerical fluxes.\n\nThis is the strong formulation, which means it should be used together with SurfaceIntegralStrongForm.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.VolumeIntegralStrongForm","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.VolumeIntegralStrongForm","text":"VolumeIntegralStrongForm()\n\nThe classical strong form volume integral type for FD/DG methods.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.VolumeIntegralWeakForm","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.VolumeIntegralWeakForm","text":"VolumeIntegralWeakForm()\n\nThe classical weak form volume integral type for DG methods as explained in standard textbooks.\n\nReferences\n\nKopriva (2009) Implementing Spectral Methods for Partial Differential Equations: Algorithms for Scientists and Engineers doi: 10.1007/978-90-481-2261-5\nHesthaven, Warburton (2007) Nodal Discontinuous Galerkin Methods: Algorithms, Analysis, and Applications doi: 10.1007/978-0-387-72067-8\n\n\n\n\n\n","category":"type"},{"location":"ref/#Semidiscretization","page":"SimpleDiscontinuousGalerkin","title":"Semidiscretization","text":"","category":"section"},{"location":"ref/#SimpleDiscontinuousGalerkin.Semidiscretization","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.Semidiscretization","text":"Semidiscretization\n\nA struct containing everything needed to describe a spatial semidiscretization of an equation.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.Semidiscretization-NTuple{4, Any}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.Semidiscretization","text":"Semidiscretization(mesh, equations, initial_condition, solver;\n                   source_terms = nothing,\n                   boundary_conditions = boundary_condition_periodic)\n\nConstruct a semidiscretization of a PDE.\n\n\n\n\n\n","category":"method"},{"location":"ref/#PolynomialBases.grid-Tuple{Semidiscretization}","page":"SimpleDiscontinuousGalerkin","title":"PolynomialBases.grid","text":"grid(semi)\n\nGet the grid of a semidiscretization.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.flat_grid-Tuple{Semidiscretization}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.flat_grid","text":"flat_grid(semi)\n\nReturn a vector of the coordinates of all nodes in semi, flattened across all elements. This is useful for plotting or other operations that require a single vector of coordinates.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.get_variable-Tuple{Any, Any, Semidiscretization}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.get_variable","text":"get_variable(u, v, semi)\n\nReturn the solution belonging to the variable v of the solution u at one time step as a vector at every node across all elements.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.jacobian_fd-Tuple{Any}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.jacobian_fd","text":"jacobian_fd(semi;\n            t0=zero(real(semi)),\n            u0_ode=compute_coefficients(t0, semi))\n\nUses the right-hand side operator of the semidiscretization semi and simple second order finite difference to compute the Jacobian J of the semidiscretization semi at state u0_ode.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.semidiscretize-Tuple{Semidiscretization, Any}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.semidiscretize","text":"semidiscretize(semi::Semidiscretization, tspan)\n\nWrap the semidiscretization semi as an ODE problem in the time interval tspan that can be passed to solve from the SciML ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Callbacks","page":"SimpleDiscontinuousGalerkin","title":"Callbacks","text":"","category":"section"},{"location":"ref/#SimpleDiscontinuousGalerkin.AnalysisCallback","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.AnalysisCallback","text":"AnalysisCallback(semi; interval=0,\n                       extra_analysis_errors=Symbol[],\n                       extra_analysis_integrals=(),\n                       io=stdout)\n\nAnalyze a numerical solution every interval time steps. The L2- and the L∞-norm for each component are computed by default. Additional errors can be computed, e.g. by passing extra_analysis_errors = (:conservation_error,).\n\nFurther scalar functions func in extra_analysis_integrals are applied to the numerical solution and integrated over the computational domain. Some examples for this are mass, and entropy. You can also write your own function with the same signature as the examples listed above and pass it via extra_analysis_integrals. The computed errors and integrals are saved for each timestep and can be obtained by calling errors and integrals.\n\nDuring the Simulation, the AnalysisCallback will print information to io.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.errors-Union{Tuple{DiscreteCallback{Condition, Affect!}}, Tuple{Affect!}, Tuple{Condition}} where {Condition, Affect!<:AnalysisCallback}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.errors","text":"errors(analysis_callback)\n\nReturn the computed errors for each timestep as a named tuple. The shape of each entry is (nvariables, ntimesteps).\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.integrals-Union{Tuple{DiscreteCallback{Condition, Affect!}}, Tuple{Affect!}, Tuple{Condition}} where {Condition, Affect!<:AnalysisCallback}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.integrals","text":"integrals(analysis_callback)\n\nReturn the computed integrals for each time step as a named tuple.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.tstops-Union{Tuple{DiscreteCallback{Condition, Affect!}}, Tuple{Affect!}, Tuple{Condition}} where {Condition, Affect!<:AnalysisCallback}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.tstops","text":"tstops(analysis_callback)\n\nReturn the time values that correspond to the saved values of the errors and integrals.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.StepsizeCallback","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.StepsizeCallback","text":"StepsizeCallback(; cfl=1.0, interval = 1)\n\nSet the time step size according to a CFL condition with CFL number cfl if the time integration method isn't adaptive itself.\n\nThe supplied keyword argument cfl must be either a Real number or a function of time t returning a Real number. By default, the timestep will be adjusted at every step. For different values of interval, the timestep will be adjusted every interval steps.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.SummaryCallback","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.SummaryCallback","text":"SummaryCallback(io::IO = stdout)\n\nCreate and return a callback that resets the timer at the beginning of a simulation and prints the timer values at the end of the simulation.\n\n\n\n\n\n","category":"type"},{"location":"ref/#Utilities","page":"SimpleDiscontinuousGalerkin","title":"Utilities","text":"","category":"section"},{"location":"ref/#SimpleDiscontinuousGalerkin.convergence_test-Tuple{Module, Any, Any}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.convergence_test","text":"convergence_test([mod::Module=Main,] example, iterations; io::IO = stdout, kwargs...)\nconvergence_test([mod::Module=Main,] example, Ns::AbstractVector; io::IO = stdout, kwargs...)\n\nRun multiple simulations using the setup given in example and compute the experimental order of convergence (EOC) in the L^2 and L^infty norm. If iterations is passed as integer, in each iteration, the resolution of the respective mesh will be doubled. If Ns is passed as vector, the simulations will be run for each value of Ns. Additional keyword arguments kwargs... and the optional module mod are passed directly to trixi_include.\n\nAdjusted from Trixi.jl.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.default_example-Tuple{}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.default_example","text":"default_example()\n\nReturn the path to an example that can be used to quickly see SimpleDiscontinuousGalerkin.jl in action. See also examples_dir.\n\nCopied from Trixi.jl.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.examples_dir-Tuple{}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.examples_dir","text":"examples_dir()\n\nReturn the directory where the example files provided by SimpleDiscontinuousGalerkin.jl are located. If SimpleDiscontinuousGalerkin.jl is installed as a regular package (with ]add SimpleDiscontinuousGalerkin), these files are read-only and should not be modified. To find out which files are available, use, e.g., readdir.\n\nCopied from Trixi.jl.\n\nExamples\n\nreaddir(examples_dir())\n\n\n\n\n\n","category":"method"},{"location":"#SimpleDiscontinuousGalerkin.jl","page":"Home","title":"SimpleDiscontinuousGalerkin.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Docs-dev) (Image: Build Status) (Image: codecov) (Image: Aqua QA) (Image: License: MIT)","category":"page"},{"location":"","page":"Home","title":"Home","text":"SimpleDiscontinuousGalerkin.jl is a Julia package that implements some basic discontinuous Galerkin (DG) methods for the solution of hyperbolic partial differential equations (PDEs). The package is designed to be simple and easy to use and understand. It is intended for educational purposes and to provide a starting point for more complex DG methods. For a more comprehensive and advanced implementation of DG methods, we recommend using the package Trixi.jl. This package can be understood as a minimalistic version of Trixi.jl, which is designed to be easy to understand and modify. Many design concepts are inspired by Trixi.jl, but the implementation is much simpler and more straightforward. SimpleDiscontinuousGalerkin.jl builds on the foundations of the package SummationByPartsOperators.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have not yet installed Julia, then you first need to download Julia. Please follow the instructions for your operating system. SimpleDiscontinuousGalerkin.jl works with Julia v1.10 and newer. You can install SimpleDiscontinuousGalerkin.jl by executing the following commands from the Julia REPL","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\n\njulia> Pkg.add(\"https://github.com/JoshuaLampert/SimpleDiscontinuousGalerkin.jl\")","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the Julia REPL, first load the package SimpleDiscontinuousGalerkin.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using SimpleDiscontinuousGalerkin","category":"page"},{"location":"","page":"Home","title":"Home","text":"SimpleDiscontinuousGalerkin.jl is built on top of the package SummationByPartsOperators.jl and exports all the functions and types of the package.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is developed and maintained by Joshua Lampert (University of Hamburg).","category":"page"},{"location":"#License-and-contributing","page":"Home","title":"License and contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SimpleDiscontinuousGalerkin.jl is published under the MIT license (see License). We are pleased to accept contributions from everyone, preferably in the form of a PR.","category":"page"}]
}
